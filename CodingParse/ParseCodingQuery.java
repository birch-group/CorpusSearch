/* Generated By:JavaCC: Do not edit this line. ParseCodingQuery.java */
package CodingParse;

import java.util.*;
import java.io.*;

import command.*;
import syntree.*;
import search_result.*;
import search.*;
import basicinfo.*;
import coding.*;

class RootNode {
    LinkedList colnodes;

    public RootNode(LinkedList in_colnodes) {
       this.colnodes = in_colnodes; }

    public CodingResult evaluate(SynTree sparse){
       CodingResult cr = new CodingResult();
       ColumnResult colres;
       ColNode cn;

       for (int i = 0; i < colnodes.size(); i++) {
            cn = (ColNode)colnodes.get(i);
            colres = cn.evaluate(sparse);
            cr.addColumnResult(colres); }
       return cr;
    }

    public void PrintToSystemErr() {
       System.err.println("RootNode:  ");
       for (int i = 0; i < colnodes.size(); i++) {
           ColNode cn = (ColNode)colnodes.get(i);
           cn.PrintToSystemErr(); }
       System.err.println(""); }
}

class ColNode {
    LinkedList scnodes;
    ColNumNode cnn;

    public ColNode(ColNumNode in_cnn, LinkedList in_scnodes) {
        this.scnodes = in_scnodes;
        this.cnn = in_cnn; }

    public ColumnResult evaluate(SynTree sparse) {
        ColumnResult cr = new ColumnResult(cnn.getNum());
        SubColNode scn;
        SubColumnResult scr;

        for (int i = 0; i < scnodes.size(); i++) {
            scn = (SubColNode)scnodes.get(i);
            scr = scn.evaluate(sparse);
            cr.addSubColumnResult(scr); }
        return cr;
    }

    public void PrintToSystemErr() {
        SubColNode scn;
        System.err.println("ColNode:  ");
        cnn.PrintToSystemErr();
        for (int i = 0; i < scnodes.size(); i++) {
            scn = (SubColNode)scnodes.get(i);
            scn.PrintToSystemErr(); }
        System.err.println();
    }
}

class SubColNode {
    ColLabelNode cl;
    QueryNode qn;

    public SubColNode(ColLabelNode in_cl, QueryNode in_qn) {
        this.cl = in_cl;
        this.qn = in_qn;
        (this.qn).hist = new History(); }

    public void PrintToSystemErr() {
        System.err.println("SubColNode:  ");
        cl.PrintToSystemErr();
        qn.PrintToSystemErr(); }

    public SubColumnResult evaluate(SynTree sparse) {
        SubColumnResult scr;
        SentenceResult sr;

        ((this.qn).hist).removeAllElements();
        sr = (this.qn).evaluate(sparse);
        scr = new SubColumnResult(cl.getLabel(), sr);
        return(scr);
    }
}

class ColNumNode{
    int col_int;
    Integer col_Int;
    String num_str;

    public ColNumNode(String collapse) {
        // remove trailing ":".
        num_str = collapse.substring(0, collapse.length() - 1);
        col_Int = new Integer(num_str);
        col_int = col_Int.intValue();
        //this.PrintToSystemErr(); 
    }

    public int getNum() {
        return col_int; }

    public void PrintToSystemErr() {
        System.err.println("ColNumNode:  ");
        System.err.println(col_int); }
}

class ColLabelNode{
    String label;

    public ColLabelNode(String label_in) {
        // remove trailing ":".
        label = label_in.substring(0, label_in.length() - 1);
        // if label begins with escape character, remove it.
        if (label.startsWith("\\")) {
            label = label.substring(1, label.length()); }
        //this.PrintToSystemErr(); 
    }

    public String getLabel() {
        return label; }

    public void PrintToSystemErr() {
        System.err.println("ColLabelNode:  ");
        System.err.println(label); }
}


abstract class QueryNode {
    public abstract SentenceResult evaluate(SynTree sparse);
    public abstract void PrintToSystemErr();
    Vector args_for_same;
    public static History hist;

    public static SentenceResult Record (SentenceResult sr) {
      hist.addSentenceResult(sr);
      return(sr); }
}

class ElseNode extends QueryNode {

    protected ElseNode () {}

    public SentenceResult evaluate(SynTree sparse) {
        return(Bounds.Basic(sparse)); }

    public void PrintToSystemErr() {
        System.err.println("ElseNode:  "); }
}

class NotNode extends QueryNode {
    protected QueryNode qn;

    protected NotNode (QueryNode qn1) {
        this.qn = qn1;
        this.args_for_same = qn1.args_for_same;
        //this.PrintToSystemErr();
    }

    public SentenceResult evaluate(SynTree sparse) {
        SentenceResult sr;

        sr = (this.qn).evaluate(sparse);
        return Record(Logicks.Not(sparse, sr, args_for_same.size(), hist)); }

    public void PrintToSystemErr() {
        System.err.println("NotNode:"); }
}

abstract class BinaryLogicNode extends QueryNode{ //AND, OR, XOR.

    protected BinaryLogicNode() {}

    protected BinaryLogicNode (LinkedList qnodes)
        { Init(qnodes); }

    protected void Init (LinkedList qnodes) {
        QueryNode qn;
        int i, j;
        Vector qn_same;

        this.qnodes = qnodes;
        if (qnodes.size() > 0) {
            this.qn1 = (QueryNode)qnodes.get(0); }
        if (qnodes.size() > 1) {
            this.qn2 = (QueryNode)qnodes.get(1); }
        this.args_for_same = new Vector();
        for (i = 0; i < qnodes.size(); i++) {
            qn = (QueryNode)qnodes.get(i);
            qn_same = qn.args_for_same;
            for (j = 0; j < qn_same.size(); j++) {
                (this.args_for_same).addElement((String)qn_same.elementAt(j));
            }
        }
    }

    public void PrintToSystemErr() {
        System.err.println("BinaryLogicNode:  ");
    }

    protected QueryNode qn1;
    protected QueryNode qn2;
    protected LinkedList qnodes;
}

class AndNode extends BinaryLogicNode {
    SameList list_o_same;

    public AndNode(LinkedList qnodes)
        { super.Init(qnodes); }
          //this.PrintToSystemErr();}

    public SentenceResult evaluate(SynTree sparse) {
        SentenceResult sr1, sr2, sr3, sr4;
        Vector arg_List;
        int qdex;
        QueryNode qn3;

        sr1  = (this.qn1).evaluate(sparse);
        if ((this.qnodes).size() == 1) {
            return sr1; }
        sr2 = (this.qn2).evaluate(sparse);
        args_for_same = new Vector();
        this.addToArgsList(this.qn1, args_for_same);
        this.addToArgsList(this.qn2, args_for_same);
        list_o_same = Commander.Sameness(args_for_same);
        sr3 = (Logicks.And(sr1, sr2, list_o_same));
        for (qdex = 2; qdex < (this.qnodes).size(); qdex++) {
            qn3 = (QueryNode)qnodes.get(qdex);
            addToArgsList(qn3, args_for_same);
            list_o_same = Commander.Sameness(args_for_same);
            sr4 = qn3.evaluate(sparse);
            sr3 = (Logicks.And(sr3, sr4, list_o_same)); }
        return sr3;
    }

    private void addToArgsList (QueryNode qn, Vector arg_list) {

        if ((qn.args_for_same).size() == 0) {
            System.err.println("WARNING! Empty args_for_same:  ");
            qn.PrintToSystemErr(); }
        for (int i = 0; i < (qn.args_for_same).size(); i++) {
            arg_list.addElement((String)(qn.args_for_same).elementAt(i)); }
        return;
    }

    public void PrintToSystemErr() {
        System.err.println("AndNode:"); }
}

class OrNode extends BinaryLogicNode{

      public OrNode(LinkedList qnodes)
        { super.Init(qnodes); }
          //this.PrintToSystemErr();}

      public SentenceResult evaluate(SynTree sparse) {
        SentenceResult sr1, sr2, sr3, sr4;
        QueryNode qn3;
        int qdex;

        sr1  = (this.qn1).evaluate(sparse);
        if ((this.qnodes).size() == 1) {
          return sr1; }
        sr2 = (this.qn2).evaluate(sparse);
        sr3 = (Logicks.Or(sr1, sr2));
        for (qdex = 2; qdex < (this.qnodes).size(); qdex++) {
            qn3 = (QueryNode)qnodes.get(qdex);
            sr4 = qn3.evaluate(sparse);
            sr3 = (Logicks.Or(sr3, sr4)); }
        return sr3; }

      public void PrintToSystemErr() {
          System.err.println("OrNode:  "); }
}

class ArgNode{
     String args;
     // prefix_args is used for the same_list.  It's args with prefix,
     // if  one exists.
     String prefix_args, prefix;
     ArgList args_for_search;
     boolean denied = false;

    public ArgNode(String argo, boolean is_denied, String prefox) {
        this.prefix_args = prefox + argo;
        this.args = argo;
        this.denied = is_denied;
        this.prefix = prefox;
        this.args_for_search = new ArgList(this.args);
        CommandAux.CheckListForIgnore(this.args_for_search);
        //this.PrintToSystemErr();
    }

    public boolean IsDenied ()
        { return denied; }

    public void PrintToSystemErr() {
        System.err.println("ArgNode:  ");
        System.err.println(args_for_search);
    }
}

class IntArgNode{
    int int_arg;
    Integer arg_Int;

    public IntArgNode(String argo) {
        arg_Int = new Integer(argo);
        int_arg = arg_Int.intValue();
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr() {
        System.err.println("IntArgNode:  ");
        System.err.println(int_arg); }
}

abstract class ThreeListsNode extends QueryNode { // iDomsMod
    ArgNode arg1, arg2, arg3;
    ArgList x_List, y_List, z_List;

    protected ThreeListsNode () {}

    protected ThreeListsNode(ArgNode arg1, ArgNode arg2, ArgNode arg3)
        { Init(arg1, arg2, arg3); }

    protected void Init(ArgNode arg1, ArgNode arg2, ArgNode arg3) {
        this.arg1 = arg1;
        this.arg2 = arg2;
        this.arg3 = arg3;
        this.x_List = arg1.args_for_search;
        this.y_List = arg3.args_for_search;
        this.z_List = arg2.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg3.prefix_args);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr() {
        System.err.println("ThreeListsNode:  ");
        System.err.println("x_List: " + this.x_List);
        System.err.println("y_List: " + this.y_List);
        System.err.println("z_List: " + this.z_List); }
}

class iDomsModNode extends ThreeListsNode {

    public iDomsModNode (ArgNode arg1, ArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
           { return Record(iDomsMod.Not_x(sparse, x_List, z_List, y_List)); }
        if (arg3.IsDenied())
           { return Record(iDomsMod.Not_y(sparse, x_List, z_List, y_List)); }
        return Record(iDomsMod.Plain(sparse, x_List, z_List, y_List)); }
}


class iDomsViaTraceNode extends ThreeListsNode {

    public iDomsViaTraceNode (ArgNode arg1, ArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
           { return Record(iDomsViaTrace.Not_x(sparse, x_List, z_List, y_List)); }
        if (arg3.IsDenied())
           { return Record(iDomsViaTrace.Not_y(sparse, x_List, z_List, y_List)); }
        return Record(iDomsViaTrace.Plain(sparse, x_List, z_List, y_List)); }
}


abstract class TrinarySearchNode extends QueryNode {
    ArgNode arg1, arg2;
    ArgList x_List, y_List;
    IntArgNode intarg1;
    int arg_int;

    protected TrinarySearchNode() {}

    protected TrinarySearchNode(ArgNode arg1, IntArgNode intarg1,
                                ArgNode arg2)
        { Init(arg1, intarg1, arg2); }

    protected void Init(ArgNode arg1, IntArgNode intarg1, ArgNode arg2) {
        this.arg_int = intarg1.int_arg;
        this.arg1 = arg1;
        this.arg2 = arg2;
        this.x_List = arg1.args_for_search;
        this.y_List = arg2.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg2.prefix_args);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr() {
        System.err.println("TrinarySearchNode:  ");
        System.err.println("x_List: " + this.x_List);
        System.err.println("y_List: " + this.y_List);
        System.err.println("arg_int: " + this.arg_int); }
}

abstract class BinarySearchNode extends QueryNode {
    ArgNode arg1, arg2;
    ArgList x_List, y_List;

    protected BinarySearchNode() {}

    protected BinarySearchNode(ArgNode arg1, ArgNode arg2)
        { Init(arg1, arg2); }

    protected void Init(ArgNode arg1, ArgNode arg2) {
        this.arg1 = arg1;
        this.arg2 = arg2;
        this.x_List = arg1.args_for_search;
        this.y_List = arg2.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg2.prefix_args);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in BinarySearchNode:  ");
        System.err.println("x_List:  " + x_List);
        System.err.println("y_list:  " + y_List);
        System.err.println("args_for_same: " + args_for_same); }
}

abstract class IntBinarySearchNode extends QueryNode { // DomsWords, DomsWordsLess...
    ArgNode arg1;
    IntArgNode intarg1;
    ArgList x_List;
    int arg_int;

    protected IntBinarySearchNode() {}

    protected IntBinarySearchNode(ArgNode arg1, IntArgNode intarg1)
        { Init(arg1, intarg1); }

    protected void Init(ArgNode arg1, IntArgNode intarg1) {
        this.arg1 = arg1;
        this.intarg1 = intarg1;
        this.x_List = arg1.args_for_search;
        this.arg_int = intarg1.int_arg;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg1.prefix_args);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in IntBinarySearchNode:  ");
        System.err.println("x_List:  " + x_List);
        System.err.println("args_for_same: " + args_for_same);
        System.err.println("arg_int: " + arg_int); }
}
/* the following SHAMELESS HACK was implemented to deal with the 
too-many-tokens problem.  I found that javacc could not handle more tokens 
normally.  To work around this, I collapsed several tokens together, 
to be differentiated later in the program. */

abstract class HackIntBinarySearchNode extends QueryNode {
// DomsWords, DomsWordsLess...
    ArgNode arg1;
    IntArgNode intarg1;
    ArgList x_List;
    String which_search;
    int arg_int;

    protected HackIntBinarySearchNode() {}

    protected HackIntBinarySearchNode(ArgNode arg1, IntArgNode intarg1,
                                      String ws)
        { Init(arg1, intarg1, ws); }

    protected void Init(ArgNode arg1, IntArgNode intarg1, String ws) {
        this.which_search = ws;
        this.arg1 = arg1;
        this.intarg1 = intarg1;
        this.x_List = arg1.args_for_search;
        this.arg_int = intarg1.int_arg;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg1.prefix_args);
        //this.curlies_list = new Vector();
        //curlies_list.addElement(arg1.curlies);
        //curlies_list.addElement(arg1.curlies);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in HackIntBinarySearchNode:  ");
        System.err.println("which_search: " + which_search);
        System.err.println("x_List:  " + x_List);
        System.err.println("args_for_same: " + args_for_same);
        System.err.println("arg_int: " + arg_int); }
}

abstract class UnarySearchNode extends QueryNode { // isRoot, Exists
    ArgNode arg1;
    ArgList x_List;

    protected UnarySearchNode() {}

    protected UnarySearchNode(ArgNode arg1)
        { Init(arg1); }

    protected void Init(ArgNode arg1) {
        this.arg1 = arg1;
        this.x_List = arg1.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg1.prefix_args);
  //      this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in UnarySearchNode:  ");
        System.err.println("x_List:  " + x_List);
        System.err.println("args_for_same: " + args_for_same); }
}

class IsRootNode extends UnarySearchNode {

    public IsRootNode (ArgNode arg1)
        { super.Init(arg1); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(isRoot.Not_x(sparse, x_List)); }
        return Record(isRoot.Plain(sparse, x_List)); }
}

class ExistsNode extends UnarySearchNode {

    public ExistsNode (ArgNode arg1)
        { super.Init(arg1); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(Exists.Not_x(sparse, x_List)); }
        return Record(Exists.Plain(sparse, x_List)); }
}

class inIDNode extends UnarySearchNode {

    public inIDNode (ArgNode arg1)
        { super.Init(arg1); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(inID.Not_x(sparse, x_List)); }
        return Record(inID.Plain(sparse, x_List)); }
}

class ColumnNode extends TrinarySearchNode {

    public ColumnNode (ArgNode arg1, IntArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg2.IsDenied())
            { return Record(Column.Not_y(sparse, x_List, arg_int, y_List)); }
        return Record(Column.Plain(sparse, x_List, arg_int, y_List)); }
}

class iDomsNumberNode extends TrinarySearchNode {

    public iDomsNumberNode (ArgNode arg1, IntArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg2.IsDenied())
            { return Record(iDomsNumber.Not_y(sparse, x_List, y_List, arg_int)); }
        return Record(iDomsNumber.Plain(sparse, x_List, y_List, arg_int)); }
}

class DomsWordsStuffNode extends HackIntBinarySearchNode {

    public DomsWordsStuffNode (ArgNode arg1, IntArgNode intarg1, String which)
        { super.Init(arg1, intarg1, which); }

    public SentenceResult evaluate(SynTree sparse) {
        return Record(DomsWordsAssign.Plain(sparse, x_List,
                                            arg_int, which_search)); }
}

class iDomsTotalStuffNode extends HackIntBinarySearchNode {

    public iDomsTotalStuffNode (ArgNode arg1, IntArgNode intarg1, String which)
        { super.Init(arg1, intarg1, which); }

    public SentenceResult evaluate(SynTree sparse) {
        return Record(iDomsTotalAssign.Plain(sparse, x_List,
                                            arg_int, which_search)); }
}

class CCommandsNode extends BinarySearchNode {

    public CCommandsNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
          { return Record(CCommands.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(CCommands.Not_y(sparse, x_List, y_List)); }
        return Record(CCommands.Plain(sparse, x_List, y_List)); }
}

class SameIndexNode extends BinarySearchNode {

    public SameIndexNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
           { return Record(SameIndex.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(SameIndex.Not_y(sparse, x_List, y_List)); }
        return Record(SameIndex.Plain(sparse, x_List, y_List)); }
}


class HasLabelNode extends BinarySearchNode {

    public HasLabelNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(hasLabel.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(hasLabel.Not_y(sparse, x_List, y_List)); }
        return Record(hasLabel.Plain(sparse, x_List, y_List)); }
}

class DomsNode extends BinarySearchNode {

    public DomsNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(Dominates.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(Dominates.Not_y(sparse, x_List, y_List)); }
        return Record(Dominates.Plain(sparse, x_List, y_List)); }
}

class DomsTNode extends BinarySearchNode {

    public DomsTNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(DominatesT.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(DominatesT.Not_y(sparse, x_List, y_List)); }
        return Record(DominatesT.Plain(sparse, x_List, y_List)); }
}

class iDomsNode extends BinarySearchNode {

    public iDomsNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iDominates.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iDominates.Not_y(sparse, x_List, y_List)); }
        return Record(iDominates.Plain(sparse, x_List, y_List)); }
}

class iDomsLastNode extends BinarySearchNode {

    public iDomsLastNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iDomsLast.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iDomsLast.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsLast.Plain(sparse, this.x_List, this.y_List)); }
}

class iDomsFirstNode extends BinarySearchNode {

    public iDomsFirstNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iDomsFirst.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iDomsFirst.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsFirst.Plain(sparse, this.x_List, this.y_List)); }
}

class iDomsOnlyNode extends BinarySearchNode {

    public iDomsOnlyNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iDomsOnly.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iDomsOnly.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsOnly.Plain(sparse, this.x_List, this.y_List)); }
}

class iDomsTNode extends BinarySearchNode {

    public iDomsTNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
          { return Record(iDomsT.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(iDomsT.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsT.Plain(sparse, this.x_List, this.y_List)); }
}

class HasSisterNode extends BinarySearchNode {

    public HasSisterNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(HasSister.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(HasSister.Not_y(sparse, x_List, y_List)); }
        return Record(HasSister.Plain(sparse, x_List, y_List)); }
}

class iPresNode extends BinarySearchNode {

    public iPresNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iPrecedes.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iPrecedes.Not_y(sparse, x_List, y_List)); }
        return Record(iPrecedes.Plain(sparse, x_List, y_List)); }
}

class PresNode extends BinarySearchNode {

    public PresNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(Precedes.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(Precedes.Not_y(sparse, x_List, y_List)); }
        return Record(Precedes.Plain(sparse, x_List, y_List)); }
}

public class ParseCodingQuery implements ParseCodingQueryConstants {
    public static QueryNode qn;
    public static RootNode rn;

  public static void main(String args[]) throws ParseException {
    System.err.println("BULLWINKLE! This method does nothing.");
  }

  public static RootNode makeCodingQueryTree(StringReader sread)
      throws ParseException{

          ParseCodingQuery parser = new ParseCodingQuery(sread);
          rn = parser.CodeRoot();
          FlushQuery();
          //Syntax.replace_index = qn.getReplaceIndex();
          //System.err.println("replace_index:  " + qn.getReplaceIndex());
          return rn; }

  public static CodingResult evaluable (SynTree sparse) {
      return (rn.evaluate(sparse));
  }

  static final public void FlushQuery() throws ParseException {
    jj_consume_token(0);
            {if (true) return;}
  }

  static final public RootNode CodeRoot() throws ParseException {
    ColNode cn1, cn2;
    LinkedList cnodes = new LinkedList();
    cn1 = ColQuery();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COL_NUM:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      cn2 = ColQuery();
                                     cnodes.add(cn2);
    }
          cnodes.add(0, cn1);
        {if (true) return new RootNode(cnodes);}
    throw new Error("Missing return statement in function");
  }

  static final public ColNode ColQuery() throws ParseException {
    ColNumNode col_num;
    LinkedList scnodes = new LinkedList();
    SubColNode scn1, scn2;
    col_num = ColNum();
    jj_consume_token(OPEN_CURLY);
    scn1 = SubColQuery();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COL_LABEL:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      scn2 = SubColQuery();
                            scnodes.add(scn2);
    }
    jj_consume_token(CLOSE_CURLY);
          scnodes.add(0, scn1);
        {if (true) return new ColNode(col_num, scnodes);}
    throw new Error("Missing return statement in function");
  }

  static final public SubColNode SubColQuery() throws ParseException {
    ColLabelNode col_label;
    QueryNode qn1;
    col_label = ColLabel();
    qn1 = SubColQueryOrElse();
          {if (true) return new SubColNode(col_label, qn1);}
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode SubColQueryOrElse() throws ParseException {
    QueryNode qn1;
    Token sf_token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      sf_token = jj_consume_token(ELSE);
          {if (true) return new ElseNode();}
      break;
    case OPEN_PAREN:
    case NOT:
    case NOT_ARG:
    case PREFIX:
    case ARG:
      qn1 = OrQuery();
          {if (true) return qn1;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ColLabelNode ColLabel() throws ParseException {
    ColLabelNode cln;
    Token sf_token=null;
    String sf_label;
    sf_token = jj_consume_token(COL_LABEL);
          sf_label = sf_token.toString();
        cln = new ColLabelNode(sf_label);
        {if (true) return cln;}
    throw new Error("Missing return statement in function");
  }

  static final public ColNumNode ColNum() throws ParseException {
    ColNumNode cnn;
    Token sf_token=null;
    String sf_int;
    sf_token = jj_consume_token(COL_NUM);
          sf_int = sf_token.toString();
        cnn = new ColNumNode(sf_int);
        {if (true) return cnn;}
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode OrQuery() throws ParseException {
    QueryNode qn1, qn2;
    LinkedList qnodes = new LinkedList();
    qn1 = AndQuery();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      jj_consume_token(OR);
      qn2 = AndQuery();
                                         qnodes.add(qn2);
    }
          qnodes.add(0, qn1);
        {if (true) return new OrNode(qnodes);}
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode AndQuery() throws ParseException {
    QueryNode qn1, qn2;
    LinkedList qnodes = new LinkedList();
    qn1 = NotQuery();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
      jj_consume_token(AND);
      qn2 = NotQuery();
                                           qnodes.add(qn2);
    }
          qnodes.add(0, qn1);
        {if (true) return new AndNode(qnodes);}
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode NotQuery() throws ParseException {
    QueryNode qn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      qn = Atom_Stmt();
          {if (true) return new NotNode(qn);}
      break;
    case OPEN_PAREN:
    case NOT_ARG:
    case PREFIX:
    case ARG:
      qn = Atom_Stmt();
          {if (true) return (qn);}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode Atom_Stmt() throws ParseException {
    QueryNode qn;
    ArgNode arg1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      qn = OrQuery();
      jj_consume_token(CLOSE_PAREN);
          {if (true) return qn;}
      break;
    case NOT_ARG:
    case PREFIX:
    case ARG:
      arg1 = Arg();
      qn = UnBinTriCall(arg1);
          {if (true) return qn;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode UnBinTriCall(ArgNode arg1) throws ParseException {
   QueryNode qn;
   Token sf_token=null;
   ArgNode arg2, arg3;
   IntArgNode int_arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ISROOT:
      // Unary Call.
          sf_token = jj_consume_token(ISROOT);
          {if (true) return new IsRootNode(arg1);}
      break;
    case EXISTS:
      sf_token = jj_consume_token(EXISTS);
          {if (true) return new ExistsNode(arg1);}
      break;
    case INID:
      sf_token = jj_consume_token(INID);
          {if (true) return new inIDNode(arg1);}
      break;
    case IDOMS:
      sf_token = jj_consume_token(IDOMS);
      arg2 = Arg();
          {if (true) return new iDomsNode(arg1, arg2);}
      break;
    case IDOMSLAST:
      sf_token = jj_consume_token(IDOMSLAST);
      arg2 = Arg();
          {if (true) return new iDomsLastNode(arg1, arg2);}
      break;
    case IDOMSFIRST:
      sf_token = jj_consume_token(IDOMSFIRST);
      arg2 = Arg();
          {if (true) return new iDomsFirstNode(arg1, arg2);}
      break;
    case IDOMSONLY:
      sf_token = jj_consume_token(IDOMSONLY);
      arg2 = Arg();
          {if (true) return new iDomsOnlyNode(arg1, arg2);}
      break;
    case DOMS:
      sf_token = jj_consume_token(DOMS);
      arg2 = Arg();
          {if (true) return new DomsNode(arg1, arg2);}
      break;
    case DOMST:
      sf_token = jj_consume_token(DOMST);
      arg2 = Arg();
          {if (true) return new DomsTNode(arg1, arg2);}
      break;
    case IPRES:
      sf_token = jj_consume_token(IPRES);
      arg2 = Arg();
          {if (true) return new iPresNode(arg1, arg2);}
      break;
    case HASSISTER:
      sf_token = jj_consume_token(HASSISTER);
      arg2 = Arg();
          {if (true) return new HasSisterNode(arg1, arg2);}
      break;
    case HASLABEL:
      sf_token = jj_consume_token(HASLABEL);
      arg2 = Arg();
          {if (true) return new HasLabelNode(arg1, arg2);}
      break;
    case PRES:
      sf_token = jj_consume_token(PRES);
      arg2 = Arg();
          {if (true) return new PresNode(arg1, arg2);}
      break;
    case CCOMMANDS:
      sf_token = jj_consume_token(CCOMMANDS);
      arg2 = Arg();
          {if (true) return new CCommandsNode(arg1, arg2);}
      break;
    case SAMEINDEX:
      sf_token = jj_consume_token(SAMEINDEX);
      arg2 = Arg();
          {if (true) return new SameIndexNode(arg1, arg2);}
      break;
    case DOMSWORDSSTUFF:
      sf_token = jj_consume_token(DOMSWORDSSTUFF);
      int_arg = IntArg();
          {if (true) return(new DomsWordsStuffNode(arg1, int_arg, sf_token.toString()));}
      break;
    case IDOMSTOTALSTUFF:
      sf_token = jj_consume_token(IDOMSTOTALSTUFF);
      int_arg = IntArg();
          {if (true) return(new iDomsTotalStuffNode(arg1, int_arg,
                                         sf_token.toString()));}
      break;
    case IDOMSNUMBER:
      sf_token = jj_consume_token(IDOMSNUMBER);
      int_arg = IntArg();
      arg2 = Arg();
          {if (true) return(new iDomsNumberNode(arg1, int_arg, arg2));}
      break;
    case COLUMN:
      sf_token = jj_consume_token(COLUMN);
      int_arg = IntArg();
      arg2 = Arg();
          {if (true) return(new ColumnNode(arg1, int_arg, arg2));}
      break;
    case IDOMSMOD:
      sf_token = jj_consume_token(IDOMSMOD);
      arg2 = Arg();
      arg3 = Arg();
          {if (true) return(new iDomsModNode(arg1, arg2, arg3));}
      break;
    case IDOMSVIATRACE:
      sf_token = jj_consume_token(IDOMSVIATRACE);
      arg2 = Arg();
      arg3 = Arg();
          {if (true) return(new iDomsViaTraceNode(arg1, arg2, arg3));}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public IntArgNode IntArg() throws ParseException {
    IntArgNode ian;
    Token sf_token=null;
    String sf_int;
    sf_token = jj_consume_token(INTARG);
          sf_int = sf_token.toString();
        ian = new IntArgNode(sf_int);
        {if (true) return ian;}
    throw new Error("Missing return statement in function");
  }

  static final public ArgNode Arg() throws ParseException {
    ArgNode an;
    Token sf_token=null;
    Token sf_token_pre=null;
    String sf_name;
    String sf_prefix;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARG:
      sf_token = jj_consume_token(ARG);
          sf_name = sf_token.toString();
        an = new ArgNode(sf_name, false, "");
        {if (true) return an;}
      break;
    case PREFIX:
      sf_token_pre = jj_consume_token(PREFIX);
      sf_token = jj_consume_token(ARG);
          sf_name = sf_token.toString();
        sf_prefix = sf_token_pre.toString();
        an = new ArgNode(sf_name, false, sf_prefix);
        {if (true) return an;}
      break;
    case NOT_ARG:
      jj_consume_token(NOT_ARG);
      an = NotArg();
          {if (true) return an;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ArgNode NotArg() throws ParseException {
    ArgNode an;
    Token sf_token=null;
    Token sf_token_curly=null;
    Token sf_token_pre=null;
    String sf_prefix;
    String sf_name;
    String sf_curly;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARG:
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, true, "");
        {if (true) return an;}
      break;
    case PREFIX:
      sf_token_pre = jj_consume_token(PREFIX);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        sf_prefix = sf_token_pre.toString();
        an = new ArgNode(sf_name, true, sf_prefix);
        {if (true) return an;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  static public ParseCodingQueryTokenManager token_source;
  static JavaCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x200,0x400,0x1800,0x0,0x0,0x1000,0x1000,0xffffc000,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x2e0,0x10,0x8,0x2e0,0x2c0,0x7,0x2c0,0x280,};
   }

  public ParseCodingQuery(java.io.InputStream stream) {
     this(stream, null);
  }
  public ParseCodingQuery(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParseCodingQueryTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public ParseCodingQuery(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParseCodingQueryTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public ParseCodingQuery(ParseCodingQueryTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(ParseCodingQueryTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[43];
    for (int i = 0; i < 43; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 43; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
