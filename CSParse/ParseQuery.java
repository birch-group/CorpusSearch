/* Generated By:JavaCC: Do not edit this line. ParseQuery.java */
package CSParse;

import java.util.*;
import java.io.*;

import command.*;
import syntree.*;
import search_result.*;
import search.*;
import basicinfo.*;
import revise.*;

abstract class QueryNode {
    public abstract SentenceResult evaluate(SynTree sparse);
    public abstract void PrintToSystemErr();
    Vector args_for_same;
    Vector curlies_list;
    public static History hist;

    public static SentenceResult Record (SentenceResult sr) {
      hist.addSentenceResult(sr);
      return(sr); }
}

class NotNode extends QueryNode {
    protected QueryNode qn;

    protected NotNode (QueryNode qn1) {
        this.qn = qn1;
        this.args_for_same = qn1.args_for_same;
        this.curlies_list = qn1.curlies_list;
//	this.PrintToSystemErr();
    }

    public SentenceResult evaluate(SynTree sparse) {
        SentenceResult sr;

        sr = (this.qn).evaluate(sparse);
        return Record(Logicks.Not(sparse, sr, args_for_same.size(), hist)); }

    public void PrintToSystemErr() {
        System.err.println("NotNode:");
        System.err.println("args_for_same.size():  " + args_for_same.size()); }
}

abstract class BinaryLogicNode extends QueryNode{ //AND, OR, XOR.

    protected BinaryLogicNode() {}

    protected BinaryLogicNode (LinkedList qnodes)
        { Init(qnodes); }

    protected void Init (LinkedList qnodes) {
        QueryNode qn;
        int i, j;
        Vector qn_same;
        Vector qn_curl;

        this.qnodes = qnodes;
        if (qnodes.size() > 0) {
            this.qn1 = (QueryNode)qnodes.get(0); }
        if (qnodes.size() > 1) {
            this.qn2 = (QueryNode)qnodes.get(1); }
        this.args_for_same = new Vector();
        this.curlies_list = new Vector();
        for (i = 0; i < qnodes.size(); i++) {
            qn = (QueryNode)qnodes.get(i);
            qn_same = qn.args_for_same;
            qn_curl = qn.curlies_list;
            for (j = 0; j < qn_same.size(); j++) {
                (this.args_for_same).addElement((String)qn_same.elementAt(j)); }
            for (j = 0; j < qn_curl.size(); j++) {
                (this.curlies_list).addElement((String)qn_curl.elementAt(j)); }
        }
    }

    public void PrintToSystemErr() {
        System.err.println("BinaryLogicNode:  "); }

    protected QueryNode qn1;
    protected QueryNode qn2;
    protected LinkedList qnodes;
}

class AndNode extends BinaryLogicNode {
    SameList list_o_same;

    public AndNode(LinkedList qnodes)
        { super.Init(qnodes); }
          //this.PrintToSystemErr();}

    public SentenceResult evaluate(SynTree sparse) {
        SentenceResult sr1, sr2, sr3, sr4;
        Vector arg_List;
        int qdex;
        QueryNode qn3;

        sr1  = (this.qn1).evaluate(sparse);
        if ((this.qnodes).size() == 1) { return sr1; }
        sr2 = (this.qn2).evaluate(sparse);
        args_for_same = new Vector();
        this.addToArgsList(this.qn1, args_for_same);
        this.addToArgsList(this.qn2, args_for_same);
        list_o_same = Commander.Sameness(args_for_same);
        sr3 = (Logicks.And(sr1, sr2, list_o_same));
        for (qdex = 2; qdex < (this.qnodes).size(); qdex++) {
            qn3 = (QueryNode)qnodes.get(qdex);
            addToArgsList(qn3, args_for_same);
            list_o_same = Commander.Sameness(args_for_same);
            sr4 = qn3.evaluate(sparse);
            sr3 = (Logicks.And(sr3, sr4, list_o_same)); }
        return sr3;
    }

    private void addToArgsList (QueryNode qn, Vector arg_list) {

        for (int i = 0; i < (qn.args_for_same).size(); i++) {
            arg_list.addElement((String)(qn.args_for_same).elementAt(i)); }
        return; }

    public void PrintToSystemErr() {
        System.err.println("AndNode:"); }
}

class OrNode extends BinaryLogicNode{

      public OrNode(LinkedList qnodes)
        { super.Init(qnodes); }
          //this.PrintToSystemErr();}

      public SentenceResult evaluate(SynTree sparse) {
        SentenceResult sr1, sr2, sr3, sr4;
        QueryNode qn3;
        int qdex;

        sr1  = (this.qn1).evaluate(sparse);
        if ((this.qnodes).size() == 1) {
          return sr1; }
        sr2 = (this.qn2).evaluate(sparse);
        sr3 = (Logicks.Or(sr1, sr2));
        for (qdex = 2; qdex < (this.qnodes).size(); qdex++) {
            qn3 = (QueryNode)qnodes.get(qdex);
            sr4 = qn3.evaluate(sparse);
            sr3 = (Logicks.Or(sr3, sr4)); }
        return sr3; }

      public void PrintToSystemErr() {
          System.err.println("OrNode:  "); }
}

class ArgNode extends QueryNode{
     String args;
     // prefix_args is used for the same_list.  It's args with prefix,
     // if  one exists.
     String prefix_args, prefix, curlies;
     ArgList args_for_search;
     boolean denied = false;

    public ArgNode(String argo, boolean is_denied, String prefox,
                   String curlies) {
        if (is_denied) { this.prefix_args = prefox + "!" + argo; }
        else { this.prefix_args = prefox + argo; }
        this.args = argo;
        this.curlies = curlies;
        this.denied = is_denied;
        this.prefix = prefox;
        this.args_for_search = new ArgList(this.args);
        CommandAux.CheckListForIgnore(this.args_for_search);
        //this.PrintToSystemErr();
    }

    public boolean IsDenied ()
        { return denied; }

    // "evaluate" is here so that ArgNode can inherit
    // from QueryNode.  It is never called.
    public SentenceResult evaluate (SynTree sparse) {
      SentenceResult sr = new SentenceResult();
      return sr; }

    public void PrintToSystemErr() {
        System.err.println("ArgNode:  ");
        System.err.println("curlies:  " + this.curlies);
        System.err.println("args_for_search: " + args_for_search);
        System.err.println(""); }
}

class IntArgNode{
    int int_arg;
    Integer arg_Int;

    public IntArgNode(String argo) {
        arg_Int = new Integer(argo);
        int_arg = arg_Int.intValue();
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr() {
        System.err.println("IntArgNode:  ");
        System.err.println(int_arg); }
}

abstract class ThreeListsNode extends QueryNode { // iDomsMod
    ArgNode arg1, arg2, arg3;
    ArgList x_List, y_List, z_List;

    protected ThreeListsNode () {}

    protected ThreeListsNode(ArgNode arg1, ArgNode arg2, ArgNode arg3)
        { Init(arg1, arg2, arg3); }

    protected void Init(ArgNode arg1, ArgNode arg2, ArgNode arg3) {
        this.arg1 = arg1;
        this.arg2 = arg2;
        this.arg3 = arg3;
        this.x_List = arg1.args_for_search;
        this.y_List = arg3.args_for_search;
        this.z_List = arg2.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg3.prefix_args);
        this.curlies_list = new Vector();
        curlies_list.addElement(arg1.curlies);
        curlies_list.addElement(arg3.curlies);
//        this.PrintToSystemErr();
    }

    public void PrintToSystemErr() {
        System.err.println("ThreeListsNode:  ");
        System.err.println("x_List: " + this.x_List);
        System.err.println("y_List: " + this.y_List);
        System.err.println("z_List: " + this.z_List); }
}


abstract class TrinarySearchNode extends QueryNode {
    ArgNode arg1, arg2;
    ArgList x_List, y_List;
    IntArgNode intarg1;
    int arg_int;

    protected TrinarySearchNode() {}

    protected TrinarySearchNode(ArgNode arg1, IntArgNode intarg1,
                                ArgNode arg2)
        { Init(arg1, intarg1, arg2); }

    protected void Init(ArgNode arg1, IntArgNode intarg1, ArgNode arg2) {
        this.arg_int = intarg1.int_arg;
        this.arg1 = arg1;
        this.arg2 = arg2;
        this.x_List = arg1.args_for_search;
        this.y_List = arg2.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg2.prefix_args);
        this.curlies_list = new Vector();
        curlies_list.addElement(arg1.curlies);
        curlies_list.addElement(arg2.curlies);
//        this.PrintToSystemErr();
    }

    public void PrintToSystemErr() {
        System.err.println("TrinarySearchNode:  ");
        System.err.println("x_List: " + this.x_List);
        System.err.println("y_List: " + this.y_List);
        System.err.println("arg_int: " + this.arg_int); }
}

abstract class BinarySearchNode extends QueryNode {
    ArgNode arg1, arg2;
    ArgList x_List, y_List;

    protected BinarySearchNode() {}

    protected BinarySearchNode(ArgNode arg1, ArgNode arg2)
        { Init(arg1, arg2); }

    protected void Init(ArgNode arg1, ArgNode arg2) {
        this.arg1 = arg1;
        this.arg2 = arg2;
        this.x_List = arg1.args_for_search;
        this.y_List = arg2.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg2.prefix_args);
        this.curlies_list = new Vector();
        curlies_list.addElement(arg1.curlies);
        curlies_list.addElement(arg2.curlies);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in BinarySearchNode:  ");
        System.err.println("x_List:  " + x_List);
        System.err.println("y_list:  " + y_List);
        System.err.println("args_for_same: " + args_for_same); }
}

abstract class IntBinarySearchNode extends QueryNode { // DomsWords, DomsWordsLess...
    ArgNode arg1;
    IntArgNode intarg1;
    ArgList x_List;
    int arg_int;

    protected IntBinarySearchNode() {}

    protected IntBinarySearchNode(ArgNode arg1, IntArgNode intarg1)
        { Init(arg1, intarg1); }

    protected void Init(ArgNode arg1, IntArgNode intarg1) {
        this.arg1 = arg1;
        this.intarg1 = intarg1;
        this.x_List = arg1.args_for_search;
        this.arg_int = intarg1.int_arg;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg1.prefix_args);
        this.curlies_list = new Vector();
        curlies_list.addElement(arg1.curlies);
        curlies_list.addElement(arg1.curlies);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in IntBinarySearchNode:  ");
        System.err.println("x_List:  " + x_List);
        System.err.println("args_for_same: " + args_for_same);
        System.err.println("arg_int: " + arg_int); }
}

/* the following SHAMELESS HACK was implemented to deal with the 
too-many-tokens problem.  I found that javacc could not handle more tokens 
normally.  To work around this, I collapsed several tokens together, 
to be differentiated later in the program. */

abstract class HackIntBinarySearchNode extends QueryNode {
// DomsWords, DomsWordsLess...
    ArgNode arg1;
    IntArgNode intarg1;
    ArgList x_List;
    String which_search;
    int arg_int;

    protected HackIntBinarySearchNode() {}

    protected HackIntBinarySearchNode(ArgNode arg1, IntArgNode intarg1,
                                      String ws)
        { Init(arg1, intarg1, ws); }

    protected void Init(ArgNode arg1, IntArgNode intarg1, String ws) {
        this.which_search = ws;
        this.arg1 = arg1;
        this.intarg1 = intarg1;
        this.x_List = arg1.args_for_search;
        this.arg_int = intarg1.int_arg;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg1.prefix_args);
        this.curlies_list = new Vector();
        curlies_list.addElement(arg1.curlies);
        curlies_list.addElement(arg1.curlies);
        //this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in HackIntBinarySearchNode:  ");
        System.err.println("which_search: " + which_search);
        System.err.println("x_List:  " + x_List);
        System.err.println("args_for_same: " + args_for_same);
        System.err.println("arg_int: " + arg_int); }
}

abstract class UnarySearchNode extends QueryNode { // isRoot, Exists
    ArgNode arg1;
    ArgList x_List;

    protected UnarySearchNode() {}

    protected UnarySearchNode(ArgNode arg1)
        { Init(arg1); }

    protected void Init(ArgNode arg1) {
        this.arg1 = arg1;
        this.x_List = arg1.args_for_search;
        this.args_for_same = new Vector();
        args_for_same.addElement(arg1.prefix_args);
        args_for_same.addElement(arg1.prefix_args);
        this.curlies_list = new Vector();
        curlies_list.addElement(arg1.curlies);
        curlies_list.addElement(arg1.curlies);
  //      this.PrintToSystemErr();
    }

    public void PrintToSystemErr () {
        System.err.println("in UnarySearchNode:  ");
        System.err.println("x_List:  " + x_List);
        System.err.println("args_for_same: " + args_for_same); }
}

class iDomsModNode extends ThreeListsNode {

    public iDomsModNode (ArgNode arg1, ArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
           { return Record(iDomsMod.Not_x(sparse, x_List, z_List, y_List)); }
        if (arg3.IsDenied())
           { return Record(iDomsMod.Not_y(sparse, x_List, z_List, y_List)); }
        return Record(iDomsMod.Plain(sparse, x_List, z_List, y_List)); }
}

class iDomsViaTraceNode extends ThreeListsNode {

    public iDomsViaTraceNode (ArgNode arg1, ArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
           { return Record(iDomsViaTrace.Not_x(sparse, x_List, z_List, y_List)); }
        if (arg3.IsDenied())
           { return Record(iDomsViaTrace.Not_y(sparse, x_List, z_List, y_List)); }
        return Record(iDomsViaTrace.Plain(sparse, x_List, z_List, y_List)); }
}


class IsRootNode extends UnarySearchNode {

    public IsRootNode (ArgNode arg1)
        { super.Init(arg1); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(isRoot.Not_x(sparse, x_List)); }
        return Record(isRoot.Plain(sparse, x_List)); }
}

class ExistsNode extends UnarySearchNode {

    public ExistsNode (ArgNode arg1)
        { super.Init(arg1); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(Exists.Not_x(sparse, x_List)); }
        return Record(Exists.Plain(sparse, x_List)); }
}

class inIDNode extends UnarySearchNode {

    public inIDNode (ArgNode arg1)
        { super.Init(arg1); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(inID.Not_x(sparse, x_List)); }
        return Record(inID.Plain(sparse, x_List)); }
}

class ColumnNode extends TrinarySearchNode {

    public ColumnNode (ArgNode arg1, IntArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg2.IsDenied())
            { return Record(Column.Not_y(sparse, x_List, arg_int, y_List)); }
        return Record(Column.Plain(sparse, x_List, arg_int, y_List)); }
}


class iDomsNumberNode extends TrinarySearchNode {

    public iDomsNumberNode (ArgNode arg1, IntArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg2.IsDenied())
            { return Record(iDomsNumber.Not_y(sparse, x_List, y_List, arg_int)); }
        return Record(iDomsNumber.Plain(sparse, x_List, y_List, arg_int)); }
}

class NeighborhoodNode extends TrinarySearchNode {

    public NeighborhoodNode (ArgNode arg1, IntArgNode arg2, ArgNode arg3)
        { super.Init(arg1, arg2, arg3); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg2.IsDenied())
            { return Record(Neighborhood.Not_y(sparse, x_List, y_List, arg_int)); }
        return Record(Neighborhood.Plain(sparse, x_List, y_List, arg_int)); }
}

class DomsWordsStuffNode extends HackIntBinarySearchNode {

    public DomsWordsStuffNode (ArgNode arg1, IntArgNode intarg1, String which)
        { super.Init(arg1, intarg1, which); }

    public SentenceResult evaluate(SynTree sparse) {
        return Record(DomsWordsAssign.Plain(sparse, x_List,
                                            arg_int, which_search)); }
}

class iDomsTotalStuffNode extends HackIntBinarySearchNode {

    public iDomsTotalStuffNode (ArgNode arg1, IntArgNode intarg1, String which)
        { super.Init(arg1, intarg1, which); }

    public SentenceResult evaluate(SynTree sparse) {
        return Record(iDomsTotalAssign.Plain(sparse, x_List,
                                            arg_int, which_search)); }
}

class CCommandsNode extends BinarySearchNode {

    public CCommandsNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
          { return Record(CCommands.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(CCommands.Not_y(sparse, x_List, y_List)); }
        return Record(CCommands.Plain(sparse, x_List, y_List)); }
}


class DomsNode extends BinarySearchNode {

    public DomsNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(Dominates.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(Dominates.Not_y(sparse, x_List, y_List)); }
        return Record(Dominates.Plain(sparse, x_List, y_List)); }
}

class DomsTNode extends BinarySearchNode {

    public DomsTNode (ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(DominatesT.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(DominatesT.Not_y(sparse, x_List, y_List)); }
        return Record(DominatesT.Plain(sparse, x_List, y_List)); }
}

class iDomsNode extends BinarySearchNode {

    public iDomsNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iDominates.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iDominates.Not_y(sparse, x_List, y_List)); }
        return Record(iDominates.Plain(sparse, x_List, y_List)); }
}

class iDomsLastNode extends BinarySearchNode {

    public iDomsLastNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
           { return Record(iDomsLast.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
           { return Record(iDomsLast.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsLast.Plain(sparse, this.x_List, this.y_List)); }
}

class iDomsFirstNode extends BinarySearchNode {

    public iDomsFirstNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
          { return Record(iDomsFirst.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(iDomsFirst.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsFirst.Plain(sparse, this.x_List, this.y_List)); }
}

class iDomsOnlyNode extends BinarySearchNode {

    public iDomsOnlyNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
          { return Record(iDomsOnly.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(iDomsOnly.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsOnly.Plain(sparse, this.x_List, this.y_List)); }
}

class iDomsTNode extends BinarySearchNode {

    public iDomsTNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
          { return Record(iDomsT.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
          { return Record(iDomsT.Not_y(sparse, x_List, y_List)); }
        return Record(iDomsT.Plain(sparse, this.x_List, this.y_List)); }
}


class HasSisterNode extends BinarySearchNode {

    public HasSisterNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(HasSister.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(HasSister.Not_y(sparse, x_List, y_List)); }
        return Record(HasSister.Plain(sparse, x_List, y_List)); }
}


class PresNode extends BinarySearchNode {

    public PresNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(Precedes.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(Precedes.Not_y(sparse, x_List, y_List)); }
        return Record(Precedes.Plain(sparse, x_List, y_List)); }
}

class iPresNode extends BinarySearchNode {

    public iPresNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(iPrecedes.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(iPrecedes.Not_y(sparse, x_List, y_List)); }
        return Record(iPrecedes.Plain(sparse, x_List, y_List)); }
}

class SameIndexNode extends BinarySearchNode {

    public SameIndexNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(SameIndex.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(SameIndex.Not_y(sparse, x_List, y_List)); }
        return Record(SameIndex.Plain(sparse, x_List, y_List)); }
}

class HasLabelNode extends BinarySearchNode {

    public HasLabelNode(ArgNode arg1, ArgNode arg2)
        { super.Init(arg1, arg2); }

    public SentenceResult evaluate(SynTree sparse) {
        if (arg1.IsDenied())
            { return Record(hasLabel.Not_x(sparse, x_List, y_List)); }
        if (arg2.IsDenied())
            { return Record(hasLabel.Not_y(sparse, x_List, y_List)); }
        return Record(hasLabel.Plain(sparse, x_List, y_List)); }
}


public class ParseQuery implements ParseQueryConstants {
  public static QueryNode qn;

  public static QueryNode makeQueryTree(StringReader sread)
      throws ParseException{

          qn.hist = new History();
          ParseQuery parser = new ParseQuery(sread);
          qn = parser.OrQuery();
          //qn = parser.AndQuery();
          parser.FlushQuery();
          //System.err.println("qn.curlies_list:  " + qn.curlies_list);
          //System.err.println("WOMBATS ARE US!");
          CommandInfo.curlies = qn.curlies_list;
          return qn; }

  public static SentenceResult evaluable (SynTree sparse) {
      (qn.hist).removeAllElements();
      return (qn.evaluate(sparse)); }

  public static History getHistory () {
      return (qn.hist); }

  static final public void FlushQuery() throws ParseException {
    jj_consume_token(0);
            {if (true) return;}
  }

  static final public QueryNode OrQuery() throws ParseException {
     QueryNode qn1, qn2;
     LinkedList qnodes = new LinkedList();
    qn1 = AndQuery();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(OR);
      qn2 = AndQuery();
                                          qnodes.add(qn2);
    }
        qnodes.add(0, qn1);
        {if (true) return new OrNode(qnodes);}
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode AndQuery() throws ParseException {
    QueryNode qn1, qn2;
    LinkedList qnodes = new LinkedList();
    qn1 = NotQuery();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      jj_consume_token(AND);
      qn2 = NotQuery();
                                           qnodes.add(qn2);
    }
        qnodes.add(0, qn1);
        {if (true) return new AndNode(qnodes);}
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode NotQuery() throws ParseException {
    QueryNode qn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      qn = Atom_Stmt();
          {if (true) return new NotNode(qn);}
      break;
    case OPEN_PAREN:
    case NOT_ARG:
    case PREFIX:
    case CURLY_LIST:
    case ARG:
      qn = Atom_Stmt();
         {if (true) return (qn);}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode Atom_Stmt() throws ParseException {
    QueryNode qn;
    ArgNode arg1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      qn = OrQuery();
      jj_consume_token(CLOSE_PAREN);
          {if (true) return qn;}
      break;
    case NOT_ARG:
    case PREFIX:
    case CURLY_LIST:
    case ARG:
      arg1 = Arg();
      qn = UnBinTriCall(arg1);
          {if (true) return qn;}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public QueryNode UnBinTriCall(ArgNode arg1) throws ParseException {
   QueryNode qn;
   Token sf_token=null;
   ArgNode arg2, arg3;
   IntArgNode int_arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ISROOT:
      // Unary Call.
          sf_token = jj_consume_token(ISROOT);
          {if (true) return new IsRootNode(arg1);}
      break;
    case EXISTS:
      sf_token = jj_consume_token(EXISTS);
          {if (true) return new ExistsNode(arg1);}
      break;
    case INID:
      sf_token = jj_consume_token(INID);
          {if (true) return new inIDNode(arg1);}
      break;
    case IDOMS:
      sf_token = jj_consume_token(IDOMS);
      arg2 = Arg();
          {if (true) return new iDomsNode(arg1, arg2);}
      break;
    case IDOMSLAST:
      sf_token = jj_consume_token(IDOMSLAST);
      arg2 = Arg();
          {if (true) return new iDomsLastNode(arg1, arg2);}
      break;
    case IDOMSFIRST:
      sf_token = jj_consume_token(IDOMSFIRST);
      arg2 = Arg();
          {if (true) return new iDomsFirstNode(arg1, arg2);}
      break;
    case IDOMSONLY:
      sf_token = jj_consume_token(IDOMSONLY);
      arg2 = Arg();
          {if (true) return new iDomsOnlyNode(arg1, arg2);}
      break;
    case DOMS:
      sf_token = jj_consume_token(DOMS);
      arg2 = Arg();
          {if (true) return new DomsNode(arg1, arg2);}
      break;
    case DOMST:
      sf_token = jj_consume_token(DOMST);
      arg2 = Arg();
          {if (true) return new DomsTNode(arg1, arg2);}
      break;
    case IPRES:
      sf_token = jj_consume_token(IPRES);
      arg2 = Arg();
          {if (true) return new iPresNode(arg1, arg2);}
      break;
    case HASSISTER:
      sf_token = jj_consume_token(HASSISTER);
      arg2 = Arg();
          {if (true) return new HasSisterNode(arg1, arg2);}
      break;
    case HASLABEL:
      sf_token = jj_consume_token(HASLABEL);
      arg2 = Arg();
          {if (true) return new HasLabelNode(arg1, arg2);}
      break;
    case PRES:
      sf_token = jj_consume_token(PRES);
      arg2 = Arg();
          {if (true) return new PresNode(arg1, arg2);}
      break;
    case CCOMMANDS:
      sf_token = jj_consume_token(CCOMMANDS);
      arg2 = Arg();
          {if (true) return new CCommandsNode(arg1, arg2);}
      break;
    case SAMEINDEX:
      sf_token = jj_consume_token(SAMEINDEX);
      arg2 = Arg();
          {if (true) return new SameIndexNode(arg1, arg2);}
      break;
    case DOMSWORDSSTUFF:
      sf_token = jj_consume_token(DOMSWORDSSTUFF);
      int_arg = IntArg();
          {if (true) return(new DomsWordsStuffNode(arg1, int_arg, sf_token.toString()));}
      break;
    case IDOMSTOTALSTUFF:
      sf_token = jj_consume_token(IDOMSTOTALSTUFF);
      int_arg = IntArg();
          {if (true) return(new iDomsTotalStuffNode(arg1, int_arg,
                                         sf_token.toString()));}
      break;
    case IDOMSNUMBER:
      sf_token = jj_consume_token(IDOMSNUMBER);
      int_arg = IntArg();
      arg2 = Arg();
          {if (true) return(new iDomsNumberNode(arg1, int_arg, arg2));}
      break;
    case NEIGHBORHOOD:
      sf_token = jj_consume_token(NEIGHBORHOOD);
      int_arg = IntArg();
      arg2 = Arg();
          {if (true) return(new NeighborhoodNode(arg1, int_arg, arg2));}
      break;
    case COLUMN:
      sf_token = jj_consume_token(COLUMN);
      int_arg = IntArg();
      arg2 = Arg();
          {if (true) return(new ColumnNode(arg1, int_arg, arg2));}
      break;
    case IDOMSVIATRACE:
      sf_token = jj_consume_token(IDOMSVIATRACE);
      arg2 = Arg();
      arg3 = Arg();
          {if (true) return(new iDomsViaTraceNode(arg1, arg2, arg3));}
      break;
    case IDOMSMOD:
      sf_token = jj_consume_token(IDOMSMOD);
      arg2 = Arg();
      arg3 = Arg();
          {if (true) return(new iDomsModNode(arg1, arg2, arg3));}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public IntArgNode IntArg() throws ParseException {
    IntArgNode ian;
    Token sf_token=null;
    String sf_int;
    sf_token = jj_consume_token(INTARG);
        sf_int = sf_token.toString();
        ian = new IntArgNode(sf_int);
        {if (true) return ian;}
    throw new Error("Missing return statement in function");
  }

  static final public ArgNode Arg() throws ParseException {
    ArgNode an;
    Token sf_token=null;
    Token sf_token_pre=null;
    Token sf_token_curly=null;
    String sf_name;
    String sf_curly;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PREFIX:
      sf_token_pre = jj_consume_token(PREFIX);
      an = PreArg(sf_token_pre.toString());
          {if (true) return an;}
      break;
    case ARG:
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, false, "", "");
        {if (true) return an;}
      break;
    case NOT_ARG:
      jj_consume_token(NOT_ARG);
      an = NotArg();
          {if (true) return an;}
      break;
    case CURLY_LIST:
      sf_token_curly = jj_consume_token(CURLY_LIST);
      an = CurlyArg(sf_token_curly.toString());
          {if (true) return an;}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ArgNode PreArg(String sf_prefix) throws ParseException {
    ArgNode an;
    Token sf_token=null;
    Token sf_token_curly= null;
    String sf_name;
    String sf_curly;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARG:
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, false, sf_prefix, "");
        {if (true) return an;}
      break;
    case NOT:
      jj_consume_token(NOT);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, true, sf_prefix, "");
        {if (true) return an;}
      break;
    case CURLY_LIST:
      sf_token_curly = jj_consume_token(CURLY_LIST);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        sf_curly = sf_token_curly.toString();
        an = new ArgNode(sf_name, false, sf_prefix, sf_curly);
        {if (true) return an;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ArgNode NotArg() throws ParseException {
    ArgNode an;
    Token sf_token=null;
    Token sf_token_curly=null;
    Token sf_token_pre=null;
    String sf_prefix;
    String sf_name;
    String sf_curly;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARG:
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, true, "", "");
        {if (true) return an;}
      break;
    case PREFIX:
      sf_token_pre = jj_consume_token(PREFIX);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        sf_prefix = sf_token_pre.toString();
        an = new ArgNode(sf_name, true, sf_prefix, "");
        {if (true) return an;}
      break;
    case CURLY_LIST:
      sf_token_curly = jj_consume_token(CURLY_LIST);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        sf_curly = sf_token_curly.toString();
        an = new ArgNode(sf_name, true, "", sf_curly);
        {if (true) return an;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ArgNode CurlyArg(String curlies) throws ParseException {
    ArgNode an;
    Token sf_token=null;
    Token sf_token_pre=null;
    String sf_prefix;
    String sf_name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARG:
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, false, "", curlies);
        {if (true) return an;}
      break;
    case PREFIX:
      sf_token_pre = jj_consume_token(PREFIX);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        sf_prefix = sf_token_pre.toString();
        an = new ArgNode(sf_name, false, sf_prefix, curlies);
        {if (true) return an;}
      break;
    case NOT:
      jj_consume_token(NOT);
      sf_token = jj_consume_token(ARG);
        sf_name = sf_token.toString();
        an = new ArgNode(sf_name, true, "", "");
        {if (true) return an;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  static public ParseQueryTokenManager token_source;
  static JavaCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[9];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x200,0x200,0xfffff800,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x4,0x2,0x178,0x170,0x1,0x170,0x148,0x160,0x128,};
   }

  public ParseQuery(java.io.InputStream stream) {
     this(stream, null);
  }
  public ParseQuery(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParseQueryTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  public ParseQuery(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParseQueryTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  public ParseQuery(ParseQueryTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  public void ReInit(ParseQueryTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[42];
    for (int i = 0; i < 42; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 9; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 42; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
